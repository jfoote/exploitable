### BEGIN LICENSE ###
### Use of the CERT Basic Fuzzing Framework and related source code
### is subject to the terms of the following licenses:
###
### GNU Public License (GPL) Rights pursuant to Version 2, June 1991
### Government Purpose License Rights (GPLR) pursuant to DFARS
### 252.227.7013
###
### Portions Copyright 2013, BlackBerry Ltd. All Rights Reserved.
###
### NO WARRANTY
###
### ANY INFORMATION, MATERIALS, SERVICES, INTELLECTUAL
### PROPERTY OR OTHER PROPERTY OR RIGHTS GRANTED OR
### PROVIDED BY CARNEGIE MELLON UNIVERSITY PURSUANT TO
### THIS LICENSE (HEREINAFTER THE "DELIVERABLES") ARE ON
### AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES
### NO WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED
### AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO,
### WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE,
### MERCHANTABILITY, INFORMATIONAL CONTENT,
### NONINFRINGEMENT, OR ERROR-FREE OPERATION. CARNEGIE
### MELLON UNIVERSITY SHALL NOT BE LIABLE FOR INDIRECT,
### SPECIAL OR CONSEQUENTIAL DAMAGES, SUCH AS LOSS OF
### PROFITS OR INABILITY TO USE SAID INTELLECTUAL
### PROPERTY, UNDER THIS LICENSE, REGARDLESS OF WHETHER
### SUCH PARTY WAS AWARE OF THE POSSIBILITY OF SUCH
### DAMAGES. LICENSEE AGREES THAT IT WILL NOT MAKE ANY
### WARRANTY ON BEHALF OF CARNEGIE MELLON UNIVERSITY,
### EXPRESS OR IMPLIED, TO ANY PERSON CONCERNING THE
### APPLICATION OF OR THE RESULTS TO BE OBTAINED WITH
### THE DELIVERABLES UNDER THIS LICENSE.
###
### Licensee hereby agrees to defend, indemnify, and hold harmless
### Carnegie Mellon University, its trustees, officers, employees,
### and agents from all claims or demands made against them (and any
### related losses, expenses, or attorney's fees) arising out of, or
### relating to Licensee's and/or its sub licensees' negligent use or
### willful misuse of or negligent conduct or willful misconduct
### regarding the Software, facilities, or other rights or assistance
### granted by Carnegie Mellon University under this License,
### including, but not limited to, any claims of product liability,
### personal injury, death, damage to property, or violation of any
### laws or regulations.
###
### Carnegie Mellon University Software Engineering Institute
### authored documents are sponsored by the U.S. Department of
### Defense under Contract F19628-00-C-0003. Carnegie Mellon
### University retains copyrights in all material produced under this
### contract. The U.S.  Government retains a non-exclusive,
### royalty-free license to publish or reproduce these documents, or
### allow others to do so, for U.S.  Government purposes only
### pursuant to the copyright license under the contract clause at
### 252.227.7013.
### END LICENSE ###

'''
Implements GDB entry point for GDB 'exploitable' command

example usage:
  (gdb) source exploitable.py
  (gdb) exploitable

'''
try:
    import gdb
except ImportError as e:
    raise ImportError("This script must be run in GDB: ", str(e))

import argparse
import os
import cPickle as pickle
import re
import sys
import warnings

# Code below adds directory containing this file to python path iff this script
# is being invoked standalone (i.e. not when it is imported). Allows script
# to be executed via GDB when not on GDB's PYTHONPATH without increasing
# vulnerability to carpet bombing attacks beyond that of executing a Python script
# outside GDB.
if __name__ == "__main__":
    # Code below contains a workaround for a bug in GDB's Python API:
    # os.path.abspath returns an incorrect string when this script is sourced
    # from a path containing "~"
    abspath = os.path.abspath(__file__)
    pos = abspath.find("/~/")
    if pos != -1:
        abspath = abspath[pos+1:]
    abspath = os.path.expanduser(abspath)
    sys.path.append(os.path.dirname(abspath))

import lib.classifier as classifier
import lib.gdb_wrapper as gdb_wrapper
import lib.versions as versions

def check_version():
    '''
    Checks to see if current operating environment has been tested with
    this command. If not, a warning is generated.

    If the current operation environment is not Linux, an error is generated.
    '''
    #if not sys.platform.startswith("linux"):
    #    raise NotImplementedError("unsupported platform: {}".format(sys.platform))

    # check GDB ver
    if gdb_ver() < versions.min_gdb_version:
        warnings.warn("GDB v{} may not support required Python API".format(gdb_ver()))

_re_gdb_version = re.compile(r"\d+\.\d+")
def gdb_ver():
    '''
    Gets the GDB version number as a string.
    '''
    gdbstr = gdb.execute("show version", False, True).splitlines()[0]
    version = _re_gdb_version.search(gdbstr)
    if version is None:
        warnings.warn("Error while parsing gdb version string: {}".format(gdbstr))
    return version.group()

class NiceArgParserExit(RuntimeError):
    pass

class NiceArgParser(argparse.ArgumentParser):
    def exit(self, *args):
        raise NiceArgParserExit(*args)

class ExploitableCommand(gdb.Command):
    '''
    A GDB Command that determines how exploitable the current state of the
    Inferior (the program being debugged) is. Either prints the result to
    GDB's STDOUT or pickles the result to a file.

    This command is designed to be run just after the Inferior stops on
    a signal, before any commands that might change the underlying state
    of GDB have been issued. WARNING: This command may change the underlying
    state of GDB (ex: changing the disassembler flavor).

    Type <cmd> -h for options.
    '''
    _cmdstr = "exploitable"
    _re_gdb_pc = re.compile(r"^=>.*$")
    def __init__(self):
        '''
        Specifies the command string that invokes this Command from the GDB
        shell. See GDB Python API documentation for details
        '''
        gdb.Command.__init__(self, self._cmdstr, gdb.COMMAND_OBSCURE)

    def print_disassembly(self):
        '''
        Attempts to print some disassembled instructions from the function
        containing $pc to GDB's STDOUT. If GDB is unable to print the
        disassembled instructions, an error message will be printed.

        If GDB's version is less than 7.3, the entire disassembled function
        will be printed (if possible). Otherwise only a subset of the
        function will be printed.

        This behavior is due to a bug in the Python API of earlier versions
        of GDB. In these versions, the results of the 'disassemble' command
        are always printed directly to GDB's STDOUT rather than optionally
        being suppressed and passed as a return value via the Python API.
        '''
        if gdb_ver() < "7.3":
            try:
                gdb.execute("disas $pc", False, True)
            except RuntimeError as e:
                warnings.warn(e)
            return

        try:
            disas = gdb.execute("disas $pc", False, True).splitlines()
        except RuntimeError as e:
            warnings.warn(e)

        pos = 0
        for line in disas:
            if self._re_gdb_pc.match(line):
                break
            pos += 1
        gdb.write("\n".join(disas[max(pos-5, 0):pos+5]))

    def invoke(self, argstr, from_tty):
        '''
        Called when this Command is invoked from GDB. Prints classification of
        Inferior to GDB's STDOUT.

        Note that sys.stdout is automatically redirected to GDB's STDOUT.
        See GDB Python API documentation for details
        '''

        op = NiceArgParser(prog=self._cmdstr, description=self.__doc__)
        op.add_argument("-v", "--verbose", action="store_true",
            help="print analysis info from the Inferior")
        op.add_argument("-m", "--machine", action="store_true",
            help="Print output in a machine parsable format")
        op.add_argument("-p", "--pkl-file", type=argparse.FileType("w"),
            help="pickle exploitability classification object and store to PKL_FILE")
        op.add_argument("-a", "--asan-log", type=file,
            help="Symbolize and analyze AddressSanitizer output (assumes executable is loaded).")
        try:
            args = op.parse_args(gdb.string_to_argv(argstr))
        except NiceArgParserExit:
            return

        if args.asan_log:
            target = gdb_wrapper.ASanTarget(args.asan_log.read())
        else:
            target = gdb_wrapper.Target()

        c = classifier.Classifier().getClassification(target, machine=args.machine)
        if args.pkl_file:
            pickle.dump(c, args.pkl_file)
            return

        if args.verbose:
            gdb.write("'exploitable' version {}".format(versions.exploitable_version))
            gdb.write(" ".join([str(i) for i in os.uname()]))
            gdb.write("Signal si_signo: {} Signal si_addr: {}".format(target.si_signo(), target.si_addr()))
            gdb.write("Nearby code:")
            self.print_disassembly()
            gdb.write("Stack trace:")
            gdb.write(target.backtrace())
            gdb.write("Faulting frame: {}".format(target.faulting_frame()))

        gdb.write(str(c))
        gdb.flush()

check_version()
ExploitableCommand()

