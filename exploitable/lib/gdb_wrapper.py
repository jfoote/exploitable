### BEGIN LICENSE ###
### Use of the triage tools and related source code is subject to the terms
### of the license below.
###
### ------------------------------------------------------------------------
### Copyright (C) 2011 Carnegie Mellon University. All Rights Reserved.
### Portions Copyright 2013 BlackBerry Ltd. All Rights Reserved.
### ------------------------------------------------------------------------
### Redistribution and use in source and binary forms, with or without
### modification, are permitted provided that the following conditions are
### met:
###
### 1. Redistributions of source code must retain the above copyright
###    notice, this list of conditions and the following acknowledgments
###    and disclaimers.
###
### 2. Redistributions in binary form must reproduce the above copyright
###    notice, this list of conditions and the following disclaimer in the
###    documentation and/or other materials provided with the distribution.
###
### 3. All advertising materials for third-party software mentioning
###    features or use of this software must display the following
###    disclaimer:
###
###    "Neither Carnegie Mellon University nor its Software Engineering
###     Institute have reviewed or endorsed this software"
###
### 4. The names "Department of Homeland Security," "Carnegie Mellon
###    University," "CERT" and/or "Software Engineering Institute" shall
###    not be used to endorse or promote products derived from this software
###    without prior written permission. For written permission, please
###    contact permission@sei.cmu.edu.
###
### 5. Products derived from this software may not be called "CERT" nor
###    may "CERT" appear in their names without prior written permission of
###    permission@sei.cmu.edu.
###
### 6. Redistributions of any form whatsoever must retain the following
###    acknowledgment:
###
###    "This product includes software developed by CERT with funding
###     and support from the Department of Homeland Security under
###     Contract No. FA 8721-05-C-0003."
###
### THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND
### CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
### EXPRESS OR IMPLIED, AS TO ANY MATTER, AND ALL SUCH WARRANTIES, INCLUDING
### WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
### EXPRESSLY DISCLAIMED. WITHOUT LIMITING THE GENERALITY OF THE FOREGOING,
### CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND
### RELATING TO EXCLUSIVITY, INFORMATIONAL CONTENT, ERROR-FREE OPERATION,
### RESULTS TO BE OBTAINED FROM USE, FREEDOM FROM PATENT, TRADEMARK AND
### COPYRIGHT INFRINGEMENT AND/OR FREEDOM FROM THEFT OF TRADE SECRETS.
### END LICENSE ###
'''
A collection of Python objects that wrap and extend the GDB Python API.

The objects in this file should generally not be instantiated directly--
they should be accessed via getTarget()

Note that for many objects defined in this file, GDB is queried only when the
object is instantiated: if the state of the Inferior changes, any previously
created instances should be considered stale.
'''
try:
    import gdb
except ImportError as e:
    raise ImportError("This script must be run in GDB: ", str(e))

import hashlib
import os
import re
import warnings

from elf import read_elf_sects
from tools import AttrDict, memoized

def gdb_uint(gdb_value):
    '''
    Returns a gdb.Value of an unsigned GDB Type corresponding to the
    supplied gdb.Value.

    The GDB module (as of 7.3) evaluates expressions including certain
    registers (any register that isn't eip, esp, or ebp) to a signed type.
    So, for example, '$edx' is considered negative if the highest order bit is
    set. We treat evaluated expressions as addresses sometimes, such as
    when comparing an evaluated expression to si_addr (which is of an
    unsigned GDB.Value type). This method can be used to ensure the types
    agree and that arithmetic/boolean operations evaluate as expected.
    '''
    return int(gdb_value.cast(gdb.lookup_type("unsigned long")))

class GdbWrapperError(RuntimeError):
    '''
    Base class for errors in this module
    '''
    pass

class ProcMaps(list):
    '''
    A list of process address mappings. This object should only be instantiated
    when the Inferior is running, otherwise the string parsing may fail.
    '''
    _re_info_target = re.compile(r"""^\s+`(?P<file>.*?)',\s+file\s+type |
                                     ^\s+(?P<start>0x[0-9A-Fa-f]+)\s+-\s+
                                     (?P<end>0x[0-9A-Fa-f]+)\s+is\s+
                                     (?P<section>.*?)(\s+in\s+(?P<lib>.*?)(\.so[\.0-9]*)?)?$""", re.MULTILINE|re.VERBOSE)
    _re_gdb_sect_info = re.compile(r"^\s+(?P<start>0x[A-Fa-f0-9]+)->(?P<end>0x[A-Fa-f0-9]+) at 0x[A-Fa-f0-9]+: (?P<sect>[^\s]+)", re.MULTILINE)

    def __init__(self, osabi):
        '''
        Queries the GDB Python API for the process address space, parses
        it, and appends it to self
        '''
        list.__init__(self)

        self._files = set()
        if osabi == "GNU/Linux":
            try:
                mapstr = str(gdb.execute("info proc map", False, True))
            except gdb.error:
                self._add_by_target()
                return # probably not actually running (eg. --asan)
            header_pos = mapstr.find("Start Addr")
            if header_pos == -1:
                raise GdbWrapperError("Unable to parse \"info proc map\" string")
            maplines = mapstr[header_pos:].splitlines()[1:]
            for line in maplines:
                line = line.split()
                start, end, size, offset = tuple(int(i, 16) for i in line[0:4])
                name = " ".join(line[4:])
                ad = AttrDict(start=start, end=end, size=size,
                              offset=offset, name=name)
                self.append(ad)
        elif osabi == "QNX Neutrino":
            self._add_by_target(len(gdb.inferiors()[0].threads()))

    def _add_by_target(self, initial_stacks=0):
        '''
        initial stacks can be used to treat the first n sections in the target as thread stacks (eg. core files)
        '''
        mapstr = str(gdb.execute("info target", False, True))
        ranges = []
        fn = None
        for m in self._re_info_target.finditer(mapstr):
            if m.group("file") is not None:
                fn = os.path.basename(m.group("file"))
            else:
                lib = m.group("lib")
                if lib:
                    lib = os.path.basename(lib)
                ranges.append((int(m.group("start"), 16), int(m.group("end"), 16), fn, lib, m.group("section")))

        for i, (st, en, fn, lib, sect) in enumerate(ranges):
            if i < initial_stacks:
                # could correlate thread sp to one of the ranges, but we'll just assume for now
                # that for n threads, the first n sections in the core are the stacks
                name = "[stack]"
            elif lib is not None:
                name = lib
            else:
                name = fn
            ad = AttrDict(start=st, end=en, size=(en-st), offset=0, name=name, sect=sect)
            self.append(ad)
            #gdb.write("{}: {:#x}-{:#x} {}".format(file, ad.start, ad.end, sect))
            self._files.add(os.path.basename(fn))
        if ranges:
            self.tgt_img = ranges[0][2]

    def add_file(self, filepath, offset):
        bn = os.path.basename(filepath)
        if bn in self._files:
            return
        elf_sects = read_elf_sects(filepath)
        sects = {}
        for sect, (start, size) in elf_sects.iteritems():
            start += offset
            sects[sect] = start
            ad = AttrDict(start=start, end=start + size, size=size, offset=0, name=bn, sect=sect)
            self.append(ad)
            #gdb.write("{}: {:#x}-{:#x} {}".format(bn, ad.start, ad.end, ad.sect))
        cmd = "add-symbol-file '{}' {:#x} {}".format(filepath, sects[".text"],
                                                     " ".join("-s {} {:#x}".format(nm, st)
                                                              for (nm, st) in sects.iteritems()
                                                              if nm != ".text"))
        gdb.execute(cmd, False, True)
        self._files.add(bn)

    def __str__(self):
        result = ["{:10} {:10} {:10} {:10} {} {}".format("start", "end", "size", "offset", "name", "sect")]
        for m in self:
            result.append("{0.start:#08x} {0.end:#08x} {0.size:#08x} {0.offset:#08x} {0.name} {1}".format(m, getattr(m, "sect", "?")))
        result.append("")
        return "\n".join(result)

    def findByName(self, name):
        '''
        Returns the process address mapping whose name matches name
        or None if no such mapping is found in self.
        '''
        for sect in self:
            if sect.name == name:
                return sect
        return None

    def findByAddr(self, addr):
        '''
        Returns the process address mapping that addr falls in,
        or None if no such mapping is found in self.
        '''
        result = None
        for sect in self:
            if sect.start <= addr < sect.end:
                if result is None or sect.size < result.size:
                    result = sect
        return result

def split_expr(inst, tok):
    com = inst.index(",", tok.end(0))
    return inst[:com], inst[com:]

class Instruction(object):
    '''
    A disassembled instruction. Notable attributes include:

    gdbstr - the original string of disassembly that was used to
        populate this instance
    operands - a list of Operand instances corresponding this
        Instruction's operands, ordered by operand_order
        See Operand class documentation for details
    mnemonic - the instruction mnemonic (ex: "pop" or "rep mov")
    dest - the destination Operand of this instruction (optional--
        only exists if this Instruction has a logical destination
        operand)
    source - the source Operand of this instruction (optional)
    aux - the aux Operand of this instruction (optional)
    '''
    _x86_prefixes = ["rep", "repe", "repz", "repne", "repnz"]
    _re_hex_int = re.compile(r"(0x[A-Fa-f0-9]+)")
    _re_dis_fail = re.compile(r""".*(<internal\sdisassembler\serror>|
                                     No\sfunction\scontains\sspecified\saddress).*""", re.VERBOSE)
    _re_arm_operands = re.compile(r"""(?P<a>0x[A-Fa-f0-9]+)      | # addr
                                      (?P<b>{)                   | # start brace
                                      (?P<c>[cs]psr)             | # <PSR>
                                      (?P<e>\])                  | # end bracket
                                      _(?P<f>[cfgnqsvxz])        | # <fields|flags>
                                      (?P<g>[aif])               | # <iflags>
                                      \#(?P<i>-?[0-9]+)          | # immediate value (with #)
                                      (?P<l>lsr|lsl|asr|ror|rrx) | # shift/rotate
                                      (?P<n>[bl]e)               | # endianness
                                      (?P<p>[+-])                | # +/-
                                      (?P<q>})                   | # end brace
                                      (?P<r>r\d{1,2}|lr|pc|sp)   | # register
                                      (?P<s>\[)                  | # start bracket
                                      (?P<x>;.*)                   # semicolon annotation
                                   """, re.VERBOSE)
    _re_arm_groups = re.compile(r"[sebq]")

    def __init__(self, gdbstr, arch):
        '''
        Parses gdbstr to populate self.
        '''
        self.gdbstr = gdbstr
        if self._re_dis_fail.match(self.gdbstr):
            raise GdbWrapperError("Disassembler error detected: {}".format(self.gdbstr))
        self.operands = []

        # get instruction addr and instruction string
        inst = [pt for pt in self.gdbstr.split(":\t", 1)[1].strip().split() if pt]
        self.addr = int(self._re_hex_int.search(self.gdbstr).group(), 16)

        # get mnemonic
        if arch.startswith("i386") and inst[0] in self._x86_prefixes: # handle rep* prefixes
            self.mnemonic = " ".join(inst[0:2])
            inst = " ".join(inst[2:])
        else:
            self.mnemonic = inst[0]
            inst = " ".join(inst[1:])
            if inst == "": # handle "ret", "iret", et al.
                return

        # get operands
        self.source = None
        self.dest = None
        self.aux = None
        if arch.startswith("i386"):
            self.operands = [Operand(o) for o in inst.split(",")]
            for a, o in zip(("dest", "source", "aux"), self.operands):
                setattr(self, a, o)
        elif arch == "arm":
            # tokenize the arguments
            toks = self._re_arm_operands.findall(inst)
            form = "".join(t.lastgroup for t in toks)
            if form.endswith("x"):
                form = form[:-1]
                toks = toks[:-1]
            form = self._re_arm_groups.sub(form, lambda c:{"s": "[", "e": "]", "b": "{", "q": "}"}[c])
            strtoks = [t.group(0) for t in toks]
            if form in ["rri",           # add, adc, sub, sbc, rsb, rsc, asr, lsl, lsr, ror, and, eor, orr, orn, bic
                        "rrr",           # add, adc, sub, sbc, rsb, rsc, qadd, qdadd, qsub, qdsub,
                                         #   (s|q|sh|u|uq|uh)(add|sub|asx|sax), usad8, mul, smul, smuad, smusd, smmul,
                                         #   [su]div, asr, lsl, lsr, ror, and, eor, orr, orn, bic, pkhbt, pkhtb, [us]xta[hb], sel
                        "rrrli",         # add, adc, sub, sbc, rsb, rsc, and, eor, orr, orn, bic, pkhbt, pkhtb, [us]xta[hb]
                        "rrrlr", "rrrl", # add, adc, sub, sbc, rsb, rsc, and, eor, orr, orn, bic
                        "rir", "rirli",  # [us]sat
                        "ri",   # mov, mvn, cmp, cmn, tst, teq, srs
                        "rr",   # mov, mvn, rrx, clz, cmp, cmn, tst, teq, [us]xt[hb], rbit, rev
                        "rrli", # mov, mvn, cmp, cmn, tst, teq, [us]xt[hb]
                        "rrl", "rlr",  # mov, mvn, cmp, cmn, tst, teq
                        "rii",  # bfc
                        "rrii", # bfi, [us]bfx
                        ]:
                dst, src = split_expr(inst, toks[0])
                self.dest = ArmOperand(dst, strtoks[:1], form[:1])
                self.source = ArmOperand(src, strtoks[1:], form[1:])
            elif form == "ra": # adr, cbz, cbnz, ldr
                short = self.mnemonic[:3]
                if short in ["cbz", "cbn"]:
                    self.dest = ArmOperand("", ["pc"], "r")
                    self.source = ArmOperand(inst, strtoks, form)
                elif short in ["ldr", "adr"]:
                    dst, src = split_expr(inst, toks[0])
                    self.dest = ArmOperand(dst, strtoks[:1], form[:1])
                    self.source = ArmOperand(src, strtoks[1:], form[1:], is_pointer=(short =="ldr"))
                else:
                    raise RuntimeError("unexpected mnemonic for form \"{}\": {}".format(form, self.mnemonic))
            elif form == "rrrr": # usada8, mla, mls, ([us]mull|[us]mlal|umaal|smlsld), smla, smlad, smlald, smlsd, smmla, smmls
                if self.mnemonic in ("umull", "smull", "umlal", "smlal", "umaal", "smlsld"):
                    dst, src = split_expr(inst, toks[1])
                    dst_r = strtoks[:2]
                    dst_f = form[:2]
                    if self.mnemonic in ["umlal", "umaal", "smlal", "smlsld"]:
                        src = inst
                        src_r = strtoks
                        src_f = form
                    else:
                        src_r = strtoks[2:]
                        src_f = form[2:]
                else:
                    dst, src = split_expr(inst, toks[0])
                    dst_r = strtoks[:1]
                    dst_f = form[:1]
                    src_r = strtoks[1:]
                    src_f = form[1:]
                self.dest = ArmOperand(dst, dst_r, dst_f)
                self.source = ArmOperand(src, src_r, src_f)
            elif form in ["a", # b, bl, blx, pld, pli
                          "r"]: # bx, blx, bxj, rfe
                if self.mnemonic.startswith("b"):
                    self.dest = ArmOperand("", ["pc"], "r") # ignore LR so it evaluates properly
                    self.source = ArmOperand(inst, strtoks, form)
                elif self.mnemonic.startswith("r"):
                    self.dest = ArmOperand("", ["pc"], "r")
                    self.source = ArmOperand(inst, strtoks, form, is_pointer=True)
                else:
                    # pli/pld shouldn't fault
                    raise RuntimeError("unexpected mnemonic for form \"{}\": {}".format(form, self.mnemonic))
            elif form in ["[rr]",    # tbb, pli, pld
                          "[rrli]"]: # tbh, pli, pld
                if self.mnemonic.startswith("p"):
                    # pli/pld shouldn't fault
                    raise RuntimeError("unexpected mnemonic for form \"{}\": {}".format(form, self.mnemonic))
                self.dest = ArmOperand("", ["pc"], "r")
                self.source = ArmOperand(inst, strtoks, form, is_pointer=True)
            elif form == "rc": # mrs
                self.dest = ArmOperand(inst, strtoks[:1], form[:1])
            elif form in ["cfr", # msr
                          "cfi"]: # msr
                self.source = ArmOperand(inst, strtoks[-1:], form[-1:])
            elif form in ["g", "gi", # cpsi[de]
                          "i",       # cps, bkpt, smc, svc
                          "n"]:      # setend
                pass
            elif form in ["r[r]", # ldr, str, ldrex
                          "r[ri]", "r[rr]", "r[rpr]", "r[rrli]", "r[rprli]", "r[rrl]", "r[rprl]", # ldr, str
                          "rr[r]", # ldrd, strd, ldrexd, strex, swp
                          "rr[ri]", "rr[rr]", "rr[rpr]", "rr[rrli]", "rr[rprli]", "rr[rrl]", "rr[rprl]", # ldrd, strd
                          "rra", # ldrd
                          "rrr[r]"]: # strexd
                regs = len(form) - len(form.lstrip("r"))
                dst, src = split_expr(inst, toks[regs-1])
                if self.mnemonic.startswith("l"):
                    order = ["dest", "source"]
                else:
                    order = ["source", "dest"]
                setattr(self, order[0], ArmOperand(dst, strtoks[:regs], form[:regs]))
                setattr(self, order[1], ArmOperand(src, strtoks[regs:], form[regs:], is_pointer=True))
            elif form in ["r[r]i", "r[r]r", "r[r]pr", "r[r]rli", "r[r]prli", "r[r]rl", "r[r]prl", # ldr, str
                          "rr[r]i", # ldrd, strd
                          "rr[r]r", "rr[r]pr", "rr[r]rli", "rr[r]prli", "rr[r]rl", "rr[r]prl"]: # ldrd, strd
                regs = len(form) - len(form.lstrip("r"))
                dst, src = split_expr(inst, toks[regs-1])
                if self.mnemonic.startswith("l"):
                    order = ["dest", "source"]
                else:
                    order = ["source", "dest"]
                setattr(self, order[0], ArmOperand(dst, strtoks[:regs], form[:regs]))
                setattr(self, order[1], ArmOperand(src, strtoks[regs:regs+3], form[regs:regs+3], is_pointer=True))
            #elif form == "[r]": # pli, pld
            #elif form == "[ri]": # pli, pld
            #elif form == "[rpr]": # pli, pld
            #elif form == "[rprli]": # pli, pld
            #elif form == "[rrl]": # pli, pld
            #elif form == "[rprl]": # pli, pld
            elif form[:2] in ["r{", # ldm, stm
                              "{r"]: # pop, push
                mne = self.mnemonic
                if mne.startswith("p"):
                    form = "r" + form
                    strtoks.insert(0, "sp")
                    if mne[1] == "u": # push
                        mne = "stm"
                    else:
                        mne = "ldm"
                    dst, src = "", inst
                else:
                    dst, src = split_expr(inst, toks[0])
                if mne.startswith("s"):
                    order = ["dest", "source"]
                else:
                    order = ["source", "dest"]
                setattr(self, order[0], ArmOperand(dst, strtoks[:1], form[:1], is_pointer=True))
                setattr(self, order[1], ArmOperand(src, strtoks[1:], form[1:]))
            elif self.mnemonic in ("cdp", "mrc", "mrrc", "mcr", "ldc", "stc"):
                # coprocessor writes. very special!
                raise RuntimeError("coprocessor instructions are unhandled, and you can too!")
            else:
                raise RuntimeError("unexpected mnemonic for form \"{}\": {}".format(form, self.mnemonic))
            self.operands = [o.regs for o in (self.dest, self.source, self.aux) if o]

    def __str__(self):
        return self.gdbstr

class Operand(object):
    '''
    A disassembled instruction operand that can be evaluated. Notable
    attributes include:

    gdbstr - the original string of disassembled operand that was used to
        populate this instance
    is_pointer - True if this operand represents a pointer, False otherwise.
        For example, "DWORD PTR [eax]" is considered a pointer, "eax" is not.
    regs - a list of strings representing the registers used in this Operand
    '''
    _re_addr = re.compile(r""".*\[(.*)\]  | # DWORD PTR [eax+0x1234]
                              .*\:(.*)      # DWORD PTR gs:0x18
                           """, re.VERBOSE)
    _re_p_regs = re.compile(r"eiz|riz")
    _re_regstrs = re.compile(
                r"""^([a-z]{1,5}\d{0,2}[a-z]{0,1})(?=\s*[\*\+-])                | # "(eax)+0x1234"
                     (?<=[\*\+-])\s*([a-z]{1,5}\d{0,2}[a-z]{0,1})(?=[\s*\*\+-]) | # "xmm5+(al)-0x1234"
                     (?<=[\*\+-])\s*([a-z]{1,5}\d{0,2}[a-z]{0,1})$              | # "eax+4* (esi)"
                    ^([a-z]{1,5}\d{0,2}[a-z]{0,1})$                               # "(edi)"
                 """, re.VERBOSE)
    _re_fpu_stack = re.compile(r"(st\(.*\))")

    def __init__(self, gdbstr):
        '''
        Parses gdbstr to populate self.  ex gdbstr="BYTE PTR es:[edi]"
        '''
        self.gdbstr = gdbstr
        gdbstr = gdbstr.split("<")[0] # get rid of "<addr resolutions>"

        # get addr
        addr = self._re_addr.match(gdbstr) # ignores segment regs
        if addr:
            self.is_pointer = True
            expr = [m for m in addr.groups() if m][0]
        else:
            self.is_pointer = False
            expr = gdbstr

        # eiz(x86) and riz(64) are pseudo-index registers that
        # the CPU always evaluates to 0. GDB types them as void (DNE)
        # which can cause a type error when evaluating expression via GDB,
        # so we substitute immediate zeros
        expr = self._re_p_regs.sub("0", expr)

        self.regs = [t.group() for t in self._re_regstrs.finditer(expr)]
        # prep for GDB evaluation. ex: "edx+0x12" becomes "$edx+0x12"
        self.expr = self._re_regstrs.sub(
                      (lambda mo: "${}".format([mg for mg in mo.groups() if mg][0])),
                      expr)


    def eval(self):
        '''
        Returns the integer value of this operand as evaluated by GDB. For
        example, if eax = 0x5 and this operand is DWORD PTR[eax + 0x100],
        eval would be 0x105 (a GDB.Value)
        '''
        if "mm" in " ".join(self.regs) or self._re_fpu_stack.match(self.gdbstr):
            return 0xDEADBEEF
        else:
            # Some GDBs (GDB 7.2 Fedora vs. Ubuntu/Debian) don't compare
            # signed and unsigned integer types consistently. gdb_uint
            # is a workaround
            return gdb_uint(gdb.parse_and_eval(self.expr))

    def __str__(self):
        return self.gdbstr

class ArmOperand(Operand):
    def __init__(self, gdbstr, toklist, form, is_pointer=False):
        self.gdbstr = gdbstr
        self.regs = []
        self.is_pointer = is_pointer
        self.expr = ""
        assert len(form) == len(toklist)
        eat = False
        for f, t in zip(form, toklist):
            if f in "[]{}cfgn":
                continue
            if f in "ai":
                if not eat and self.expr:
                    self.expr += "+"
                if f == "a":
                    self.expr += "{}".format(int(t, 16))
                else:
                    self.expr += "{}".format(int(t[1:]))
                eat = False
            elif f == "l":
                self.expr += {"lsl": "<<",
                              "lsr": ">>",
                              "asr": ">>",
                              "ror": ">>",
                              "rrx": ">>1"}[t]
                if t != "rrx":
                    eat = True
            elif f == "p" and t == "-":
                self.expr += "-"
                eat = True
            elif f == "r":
                if not eat and self.expr:
                    self.expr += "+"
                self.expr += "$" + t
                eat = False
                self.regs.append(t)

class Backtrace(list):
    '''
    A backtrace composed of a list of GDB Frames (ordered from innermost to
    outermost) and other attributes, including:

    hash - an object that can be used to determine uniqueness: note that
        Backtrace does not implement hashing from the Python data model (yet)
    abnormal_termination - set to True if GDB's backtrace unwind terminated
        abnormally, such as in the case of stack corruption
    '''
    def __init__(self, target, blacklist=None, major_depth=5):
        '''
        Uses the GDB API to populate self. Any frames in
        blacklist are marked as such. The first non-blacklisted,
        major_depth frames are used to calculate the
        backtrace's major hash.
        '''
        list.__init__(self)
        self.blacklist = blacklist

        if hasattr(target, "asan_stack"):
            frame = True
        else:
            frame = gdb.selected_frame()
        hc = 0
        i = 0
        major = "0"
        minor = "0"
        self.abnormal_termination = False
        while frame:
            if hasattr(target, "asan_stack"):
                if i >= len(target.asan_stack):
                    break
                frame = ASanFrame(target, i)
            else:
                frame = Frame(target, frame, i)

            # The check below is a workaround for a known libc/gdb runaway
            # backtrace issue, see
            # http://sourceware.org/ml/libc-alpha/2012-03/msg00573.html
            if frame.name() and "libc_start_main" in frame.name():
                break

            if not self._in_blacklist(frame):
                if hc < major_depth:
                    major = hashlib.md5(major + str(frame)).hexdigest()
                minor = hashlib.md5(minor + str(frame)).hexdigest()
                hc += 1
            else:
                frame.blacklisted = True
            self.append(frame)

            # some versions of the GDB Python API do not expose a frame unwind
            # error sentinel; if it is not available a hardcoded value based on
            # an enum from GDB's gdb/frames.h is used
            unwind_error = getattr(gdb, "FRAME_UNWIND_FIRST_ERROR", 3)
            if frame.unwind_stop_reason() >= unwind_error:
                self.abnormal_termination = True
                break

            try:
                frame = frame.older()
            except RuntimeError:
                self.abnormal_termination = True
                break
            i += 1

        self.hash = AttrDict(major=major, minor=minor)

    def _in_blacklist(self, frame):
        '''
        Returns True if frame is in self.blacklist, False otherwise.
        '''
        if not self.blacklist:
            return False
        if frame.name() in self.blacklist.functions:
            return True
        if frame.mapped_region and \
           self.blacklist.map_regex.match(frame.mapped_region.name):
            return True
        return False

    def __str__(self):
        result = [str(f) for f in self]
        if self.abnormal_termination:
            reason = self[-1].unwind_stop_reason()
            result.append("abnormal stack unwind termination: {}".format(
                gdb.frame_stop_reason_string(reason)))
        return "\n".join(result)

class Frame(object):
    '''
    Wrapper for gdb.Frame. Adds frame position, pretty string, etc.

    Note: Because GDB Python API classes cannot be inherited, this class
    overloads __getattr__ to pass method calls to gdb.Frame. This may cause
    some issues with getting/setting this class's state, such as during
    pickling.
    '''
    def __init__(self, target, gdb_frame, position=None):
        self.gdb_frame = gdb_frame
        self.position = position
        self.blacklisted = False
        self.mapped_region = target.procmaps().findByAddr(self.pc())
        sym_addr = target.sym_addr(self.pc())
        if sym_addr is None:
            try:
                sym_addr = self.mapped_region.start
            except AttributeError:
                sym_addr = 0
        self.offset = self.pc() - sym_addr

    def __getattr__(self, name):
        return getattr(self.gdb_frame, name)

    def __str__(self):
        desc = "#{:3d} {} at {:#x} in {}".format(self.position, self.name(), self.pc(),
                                self.mapped_region.name if self.mapped_region else "?")
        if self.blacklisted:
            desc += " (BL)"
        return desc

    def terse(self):
        out = self.mapped_region.name if self.mapped_region else "Unknown"
        name = self.name()
        if name is not None:
            out = "{}!{}".format(out, name)
        out = "{}+{:#x}".format(out, self.offset)
        return out

class ASanFrame(Frame):
    def __init__(self, target, position=None):
        self.target = target
        self.position = position
        self.blacklisted = False
        if position is not None:
            self._pc = target.asan_stack[position].addr
            self._name = target.asan_stack[position].name
            self.offset = target.asan_stack[position].off
            self.mapped_region = target.procmaps().findByAddr(self._pc)

    @classmethod
    def create(cls, target, addr, name, offset):
        o = cls(target)
        o._pc = addr
        o._name = name
        o.offset = offset
        o.mapped_region = target.procmaps().findByAddr(addr)
        return o

    def name(self):
        return self._name

    def pc(self):
        return self._pc

    def older(self):
        try:
            # TODO: wrong?
            return self.target.asan_stack[self.position+1]
        except IndexError:
            raise RuntimeError()

    def unwind_stop_reason(self):
        return 0
    def type(self):
        return 0

    def __getattribute__(self, name):
        return object.__getattribute__(self, name)

class Target(object):
    '''
    A wrapper for a Linux GDB Inferior. Includes of various convenience
    methods used for classification.

    WARNING: Methods in this object may change the state of GDB. For
    example, the disassembly flavor may be left as "intel"
    after this code is executed.
    '''
    _re_info_frame = re.compile(r"""^\s*eip\s=\s([^\s;]*)(?:\sin\s)? # addr
                                                ([^\s;]*) # fname
                                                ([^\s;]*) # source_file:line
                                 """, re.VERBOSE)
    _re_gdb_info_sym = re.compile(r"""^\s*(?P<sym>.*?)\s+\+\s+(?P<off>[0-9]+)\s+
                                       in\s+section\s+\.text(\s+
                                       of\s+(?P<lib>.*?)\s*)?$""", re.VERBOSE)
    _re_gdb_addr_bit = re.compile(r"^gdbarch_dump: addr_bit = ([0-9]+)$", re.MULTILINE)
    _re_gdb_osabi = re.compile(r"\(currently \"(.*)\"\)")
    _re_gdb_arch = re.compile(r"\(currently\s+(.+)\)")

    # these functions and libs are not considered to be at fault for a crash
    blacklist = AttrDict(functions=("__kernel_vsyscall", "abort", "raise",
                                    "malloc", "free", "*__GI_abort",
                                    "*__GI_raise", "malloc_printerr",
                                    "__libc_message", "_int_malloc",
                                    "_int_free"),
                         map_regex=re.compile(r".*/libc(\.|-).*|.*/libm(\.|-).*"))

    def __init__(self):
        self._common_init()
        self._check_inferior_state()

    def _common_init(self):
        self.osabi = self._re_gdb_osabi.search(str(gdb.execute("show osabi", False, True))).group(1)
        arch = self._re_gdb_arch.search(str(gdb.execute("show architecture", False, True))).group(1)
        if arch.startswith("i386"):
            gdb.execute("set disassembly-flavor intel", False, True)
        self.arch = arch

    def _check_inferior_state(self):
        if len(gdb.inferiors()) != 1:
            raise GdbWrapperError("Unsupported number of inferiors ({})".format(len(gdb.inferiors())))
        if len(gdb.inferiors()[0].threads()) == 0:
            raise GdbWrapperError("No threads running")
        if not gdb.inferiors()[0].threads()[0].is_stopped:
            raise GdbWrapperError("Inferior's primary thread is not stopped")


    @memoized
    def backtrace(self):
        return Backtrace(self, self.blacklist)

    def hash(self):
        return self.backtrace().hash

    @memoized
    def procmaps(self):
        return ProcMaps(self.osabi)

    @memoized
    def faulting_frame(self):
        for frame in self.backtrace():
            if not frame.blacklisted:
                return frame
        warnings.warn("All frames blacklisted")
        return None

    @staticmethod
    def sym_addr(sym):
        try:
            return gdb_uint(gdb.parse_and_eval(str(sym)))
        except gdb.error:
            return None

    @memoized
    def current_instruction(self):
        img, addr = getattr(self, "asan_pc_img", (None, self.pc()))
        if img and os.path.basename(img) != getattr(self.procmaps(), "tgt_img", None):
            gdb.execute("file {}".format(img), False, True)
        try:
            gdbstr = gdb.execute("x/i {:#x}".format(addr), False, True).splitlines()[0]
            return Instruction(gdbstr, self.arch)
        except RuntimeError:
            return None

    @memoized
    def pc(self):
        return gdb_uint(gdb.parse_and_eval("$pc"))

    @memoized
    def stack_pointer(self):
        return gdb_uint(gdb.parse_and_eval("$sp"))

    @memoized
    def pid(self):
        return gdb.inferiors()[0].pid

    @memoized
    def pointer_size(self):
        return int(self._re_gdb_addr_bit.search(
                       gdb.execute("maint print architecture", False, True)).group(1)) / 8

    @memoized
    def si_signo(self):
        # This is a workaround to a bug in the GDB Python API:
        # The only reliable way to cause GDB to raise an exception when
        # $_siginfo is not available it to call __str__() -- otherwise
        # (such as when casting the Gdb.Value to another type), GDB may
        # force Python to abruptly exit rather than raising an exception
        str(gdb.parse_and_eval("$_siginfo.si_signo"))
        return gdb.parse_and_eval("$_siginfo.si_signo")

    @memoized
    def si_addr(self):
        if self.osabi == "QNX Neutrino":
            str(gdb.parse_and_eval("$_siginfo.__data.__fault.__addr"))
            return gdb.parse_and_eval("$_siginfo.__data.__fault.__addr")
        else:
            str(gdb.parse_and_eval("$_siginfo._sifields._sigfault.si_addr"))
            return gdb.parse_and_eval("$_siginfo._sifields._sigfault.si_addr")

class ASanTarget(Target):
    _re_asan_bt = re.compile(r"""^(\033\133[0-9]+m)* # ANSI colour code
                                  (?P<all>\s*\#(?P<frame>[0-9]+)\s*
                                  (?P<addr>0x[A-Fa-f0-9]+)\s*\()
                                  (?P<img>.*?)
                                  \+(?P<offset>0x[A-Fa-f0-9]+)\)$""", re.VERBOSE|re.MULTILINE)
#==19027== ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f0fa35f1bf1 sp 0x7fffbcc88a48 bp 0x7fffbcc89290 T0)
#==16758== ERROR: AddressSanitizer: attempting double-free on 0x60040000dff0:
#==16769== ERROR: AddressSanitizer: heap-use-after-free on address 0x60040000dff0 at pc 0x4025b1 bp 0x7ffff1dbe6c0 sp 0x7ffff1dbe6b8
#READ of size 1 at 0x60040000dff0 thread T0
    _re_asan_fault = re.compile(r"""^(\033\133[0-9]+m)* # ANSI colour code
                                     =+[0-9]+=+\s*ERROR:\s*AddressSanitizer:\s*
                                     (attempting\s)?(?P<desc>[A-Za-z0-9_-]+)\s
                                     on\s((unknown\s)?address\s)?(?P<fault>0x[A-Fa-f0-9]+)
                                     (:$ | \s(\(|at\s)
                                         pc\s(?P<pc>0x[A-Fa-f0-9]+)\s
                                         (?P<bspid1>[bs]p)\s(?P<bsp1>0x[A-Fa-f0-9]+)\s
                                         (?P<bspid2>[bs]p)\s(?P<bsp2>0x[A-Fa-f0-9]+)([\r\n]+
                                     (\033\133[0-9]+m)* # ANSI colour code
                                     (?P<operation>[A-Za-z0-9_-]+))?)""", re.VERBOSE|re.MULTILINE)
    _re_asan_report_sym = re.compile(r"^(__asan_report_error|__asan::ReportDoubleFree)")
    _re_asan_printloop = re.compile(r"^(__sanitizer::RawWrite|__sanitizer::Abort|[A-Za-z_0-9]*puts)")
    _re_symline_trim = re.compile(r" starts at address.*\s*")

    _asan_reasons = ["double-free", "bad-free", "alloc-dealloc-mismatch", "unknown-crash",
                     "heap-buffer-overflow", "global-buffer-overflow", "stack-use-after-scope",
                     "use-after-poison", "stack-use-after-return", "stack-buffer-overflow",
                     "initialization-order-fiasco", "stack-buffer-underflow", "heap-use-after-free", "SEGV"]

    def __init__(self, asan_output):
        # TODO: these might not always be False
        self.__memo__ = {"isPossibleStackCorruption()": False,
                         "isStackCorruption()": False,
                         "isStackOverflow()": False,
                         "si_signo()": 11}
        if not asan_output:
            raise GdbWrapperError("no ASan data to analyze")
        self._common_init()
        # symbolize asan_message
        self.asan_stack = []
        out = []
        last = 0
        all_frames = []
        maps = self.procmaps()
        for m in self._re_asan_bt.finditer(asan_output):
            frame, addr, img, offset = m.group("frame", "addr", "img", "offset")
            frame = int(frame)
            addr = int(addr, 16) #+ 1
            offset = int(offset, 16) #+ 1
            if img:
                maps.add_file(img, addr - offset)
            out.append(asan_output[last:m.end("all")])
            all_frames.append((frame, addr, offset, img, len(out)))
            out.append(None)
            last = m.end()
        out.append(asan_output[last:])
        frame = -1
        for num, addr, offset, img, outpos in all_frames:
            region = maps.findByAddr(addr)
            symbol = gdb.execute("info symbol {:#x}".format(addr), False, True)
            symline = gdb.execute("info line *{:#x}".format(addr), False, True)
            if symline and symline.startswith("Line"):
                symline = "\n\t{}".format(self._re_symline_trim.sub("", symline))
            else:
                symline = ""
            symbol_m = self._re_gdb_info_sym.search(symbol)
            if img:
                lib = img
            elif region:
                lib = region.name
            else:
                lib = None
            if symbol_m is None:
                sym = None
                off = offset
            else:
                sym = symbol_m.group("sym")
                off = int(symbol_m.group("off"))
            if frame == -1:
                self.asan_pc_img = lib, offset
            if frame is not None and num > frame:
                frame = num
                if lib:
                    lib = os.path.basename(lib)
                self.asan_stack.append(AttrDict(addr=addr,
                                                lib=lib,
                                                off=off,
                                                name=sym))
            else:
                frame = None
            out[outpos] = "{}){}".format(ASanFrame.create(self, addr, sym, off).terse(), symline)
        asan_output = "".join(out)
        gdb.write(asan_output)
        gdb.flush()
        # parse ASAN's analysis
        m = self._re_asan_fault.search(asan_output)
        self.__memo__["si_addr()"] = int(m.group("fault"), 16)
        self.asan_reason = m.group("desc")
        if self.asan_reason == "double-free":
            self.__memo__["pc()"] = self.asan_stack[1].addr
            self.__memo__["stack_pointer()"] = None # what to do? ....
        else:
            self.__memo__["pc()"] = int(m.group("pc"), 16)
            if m.group("bspid1") == "sp":
                self.__memo__["stack_pointer()"] = int(m.group("bsp1"), 16)
            else:
                self.__memo__["stack_pointer()"] = int(m.group("bsp2"), 16)
            if self.asan_reason != "SEGV":
                self.asan_operation = m.group("operation")

